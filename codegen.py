import os
from ast_utils import *
from ast_parser import *

class Register:
  def __init__(self, mnemonic):
    self.mnemonic = mnemonic

  def __str__(self):
    return self.mnemonic


class RegisterBank:
  def __init__(self):
    self.ip_register = Register("ip")
    self.ra = Register("ra")
    self.rb = Register("rb")
    self.rc = Register("rc")
    self.rd = Register("rd")
    self.return_register = self.ra


class CodeGenerator:
  def __init__(self, abstract_syntax_tree: Program, var_scope, funct_scope):
    self.ast = abstract_syntax_tree
    self.variable_scope = var_scope
    self.function_scope = funct_scope
    self.registers = RegisterBank()

  @staticmethod
  def _unimplemented(node):
    return f'\n; unimplemented feature: {node}\n'

  @staticmethod
  def _function_sig(function_name):
    return f"\n; function {function_name}()\n@{function_name}:\n"

  def _pop_ip(self):
    return f"  pop   {self.registers.ip_register} ; exit function\n\n"

  @staticmethod
  def _movl(register, value, comment):
    return f"  movl  {register} {value} ; {comment}\n"

  def _compile_node(self, node):
    result = str()
    if type(node) is Function:
      result += self._function_sig(node.function_name)
      result += self._compile_node(node.body)
      result += self._pop_ip()
    elif type(node) is Program:
      # TODO this is a quick hack
      for child in node.children:
        result += self._compile_node(child)
    elif type(node) is ReturnStatement:
      if type(node.value) is Integer:
        # TODO store signed ints as one's complement
        result += self._movl(
          self.registers.return_register,
          node.value,
          comment=f"return {node.value}"
        )
        result += self._pop_ip()
    else:
      result += self._unimplemented(node)
    return result

  def compile(self):
    assembly = AssemblyCode()
    assembly.code += """; tma-16 assembly code
; Code generated by the MPL compiler

; entry point of the program
jmp @__start__
    """

    main_section = Program()
    for node in self.ast.children:
      if type(node) is Function:
        self.function_scope[node.function_name] = node
      else:
        main_section.children.append(node)

    for function_id in self.function_scope.keys():
      assembly.code += self._compile_node(self.function_scope[function_id])

    assembly.code += """; entry point of the program
@__start__:
"""
    assembly.code += self._compile_node(main_section)
    assembly.code += "  halt ; end of program\n"

    return assembly


class AssemblyCode:
  def __init__(self):
    self.code = str()

  # `of` is the path to which we write our code
  def assemble(self, of: str, preserve_asm=False, gen_tmx=True, assembler_opts=""):
    asm_file_path = of.replace(".tmx", ".asm")
    print("Writing assembly file...")
    asm_file = open(asm_file_path, "w+")
    asm_file.write(self.code)
    asm_file.close()
    if gen_tmx:
      print("Assembling...")
      shell = str()
      end_shell = str()
      if os.name == "nt":
        shell = r'C:\"Program Files"\Git\usr\bin\bash.exe -c "source ~/.bashrc ; '
        end_shell = ' ;"'
      os.system(f'{shell} tmasm {asm_file_path} {assembler_opts} {end_shell}')
      if not preserve_asm:
        print("Removing assembly file...")
        os.system(f'{shell} rm {asm_file_path} {end_shell}')
      print("Finished assembling.")
    else:
      print("Assembly generated.")
