import os
from ast_utils import *
from ast_parser import *

class Register:
  def __init__(self, mnemonic):
    self.mnemonic = mnemonic

  def __str__(self):
    return self.mnemonic


class RegisterBank:
  def __init__(self):
    self.ip_register = Register("ip")
    self.ra = Register("ra")
    self.rb = Register("rb")
    self.rc = Register("rc")
    self.rd = Register("rd")
    self.return_register = self.ra


class CodeGenerator:
  def __init__(self, abstract_syntax_tree: Program, var_scope, funct_scope):
    self.ast = abstract_syntax_tree
    self.variable_scope = var_scope
    self.function_scope = funct_scope
    self.registers = RegisterBank()
    self.lowest_used_label_num = 0

  @staticmethod
  def _unimplemented(node):
    return f'\n; unimplemented feature: {node}\n'

  @staticmethod
  def _function_sig(function_name):
    return f"\n; function {function_name}()\n@{function_name}:\n"

  def _pop_ip(self):
    return f"  pop   {self.registers.ip_register} ; exit function\n\n"

  @staticmethod
  def _movl(register, value, comment):
    return f"  movl  {register}   {value} ; {comment}\n"

  @staticmethod
  def _push(register, comment):
    return f"  push  {register} ; {comment}\n"

  @staticmethod
  def _pop(register, comment):
    return f"  pop   {register} ; {comment}\n"

  @staticmethod
  def _jmp(address, comment):
    return f"  jmp      {address} ; {comment}\n"

  def _save_registers(self):
    return "; TODO save registers\n"

  def _load_saved_registers(self):
    return "; TODO load registers\n"

  def _print_statement(self, value):
    result = str()
    if type(value) is Integer:
      result += self._save_registers()
      result += self._movl(
        self.registers.ra,
        value.value,
        f"printing u16 {value.value}"
      )
      i = 0
      return_label = "__ret"
      while i <= self.lowest_used_label_num:
        i += 1
      self.lowest_used_label_num = i
      return_label = f"@{return_label}{i}"
      result += self._movl(
        self.registers.rb,
        return_label,
        "return address"
      )
      result += self._push(
        self.registers.rb,
        "return address goes on the stack first"
      )
      result += self._push(
        self.registers.ra,
        "u16 to print"
      )
      result += self._jmp("@__print_u16__", "call the subroutine")
      result += f"{return_label}: ; go here after printing\n"
      result += self._load_saved_registers()
      return result
    else:
      return self._unimplemented(value)

  def _push_local(self, value):
    # TODO implement
    pass

  def _compile_node(self, node):
    result = str()
    if type(node) is Function:
      result += self._function_sig(node.function_name)
      result += self._compile_node(node.body)
      result += self._pop_ip()
    elif type(node) is Program:
      # TODO this is a quick hack
      for child in node.children:
        result += self._compile_node(child)
    elif type(node) is ReturnStatement:
      if type(node.value) is Integer:
        # TODO store signed ints as one's complement
        result += self._movl(
          self.registers.return_register,
          node.value,
          comment=f"return {node.value}"
        )
        result += self._pop_ip()
    elif type(node) is PrintStatement:
        result += self._print_statement(node.arg)
    else:
      result += self._unimplemented(node)
    return result

  def compile(self):
    assembly = AssemblyCode()
    assembly.code += """; tma-16 assembly code
; Code generated by the MPL compiler

; entry point of the program
jmp @__start__

; library subroutines
#include "include/print.asm"
#include "include/compare_strings.asm"
#include "include/math.asm"
#include "include/memstack.asm"

#define MEM_STACK_SPACE__ 0x1000
#define HEAP_SPACE__ 0x8000
    """

    main_section = Program()
    for node in self.ast.children:
      if type(node) is Function:
        self.function_scope[node.function_name] = node
      else:
        main_section.children.append(node)

    for function_id in self.function_scope.keys():
      assembly.code += self._compile_node(self.function_scope[function_id])

    assembly.code += """; entry point of the program
@__start__:
"""
    assembly.code += self._compile_node(main_section)
    assembly.code += "  halt ; end of program\n"
    assembly.code += """;
; in-memory stack (not to be confused with the "hardware stack", aka the cache)
@__mem_stack_ptr___:
  pb    @__mem_stack__
@__mem_stack__:
  alloc MEM_STACK_SPACE__

; heap starts here
@__heap__:
  alloc HEAP_SPACE__
    """

    return assembly


class AssemblyCode:
  def __init__(self):
    self.code = str()

  # `of` is the path to which we write our code
  def assemble(self, of: str, preserve_asm=False, gen_tmx=True, assembler_opts=""):
    asm_file_path = of.replace(".tmx", ".asm")
    print("Writing assembly file...")
    asm_file = open(asm_file_path, "w+")
    asm_file.write(self.code)
    asm_file.close()
    if gen_tmx:
      print("Assembling...")
      shell = str()
      end_shell = str()
      if os.name == "nt":
        shell = r'C:\"Program Files"\Git\usr\bin\bash.exe -c "source ~/.bashrc ; '
        end_shell = ' ;"'
      os.system(f'{shell} tmasm {asm_file_path} {assembler_opts} {end_shell}')
      if not preserve_asm:
        print("Removing assembly file...")
        os.system(f'{shell} rm {asm_file_path} {end_shell}')
      print("Finished assembling.")
    else:
      print("Assembly generated.")
